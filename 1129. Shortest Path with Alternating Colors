public class Solution {
    public int[] ShortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
         var red = new List<int>[n];
 var blue = new List<int>[n];

 for (var i = 0; i < n; i++)
 {
     red[i] = new List<int>();
     blue[i] = new List<int>();
 }

 foreach (var edge in redEdges) red[edge[0]].Add(edge[1]);

 foreach (var edge in blueEdges) blue[edge[0]].Add(edge[1]);

 var result = new int[n];
 for (var i = 0; i < n; i++) result[i] = -1;

 var queue = new Queue<(int node, bool color)>();
 queue.Enqueue((0, true));
 queue.Enqueue((0, false));

 var visited = new HashSet<(int node, bool color)>();
 visited.Add((0, true));
 visited.Add((0, false));

 var level = 0;
 while (queue.Count > 0)
 {
     var count = queue.Count;
     for (var i = 0; i < count; i++)
     {
         var (node, color) = queue.Dequeue();
         if (result[node] == -1) result[node] = level;

         if (color)
         {
             foreach (var next in red[node])
                 if (!visited.Contains((next, false)))
                 {
                     queue.Enqueue((next, false));
                     visited.Add((next, false));
                 }
         }
         else
         {
             foreach (var next in blue[node])
                 if (!visited.Contains((next, true)))
                 {
                     queue.Enqueue((next, true));
                     visited.Add((next, true));
                 }
         }
     }

     level++;
 }

 return result;
    }
}
