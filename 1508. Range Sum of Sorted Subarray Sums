public class Solution {
    public int RangeSum(int[] nums, int n, int left, int right) {
        left--;//turn left through right into a normal 0-indexed range [left, right)
        //why is n given? Surely it is always equal to nums.Length? And if not, what part of nums is used?
        int min = int.MaxValue;
        int sum = 0;
        int[] prefixSums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            sum += num;
            prefixSums[i + 1] = sum;
            min = Math.Min(min, num);
        }
        int secondSum = 0;
        int[] prefixSecondSums = new int[n + 2];
        for (int i = 0; i <= n; i++) {
            int num = prefixSums[i];
            secondSum += num;
            prefixSecondSums[i + 1] = secondSum;
        }
        int sumLo = min - 1;
        int sumHi = sum + 1;
        long leftResult = 0;
        while (true) {
            int sumMid = (sumLo + sumHi) / 2;
            int ltCount = 0;
            int eqCount = 0;
            for (int i = 0; i < n; i++) {
                int prefixSum = prefixSums[i];
                int lo = i;
                int hi = n + 1;
                while (hi - lo > 1) {
                    int mid = (lo + hi) / 2;
                    int subarraySum = prefixSums[mid] - prefixSum;
                    if (subarraySum < sumMid) lo = mid;
                    else hi = mid;
                }
                ltCount += lo - i;
                if (hi <= n && prefixSums[hi] - prefixSum == sumMid) eqCount++;
            }
            if (left < ltCount) sumHi = sumMid;
            else if (ltCount + eqCount < left) sumLo = sumMid;
            else {
                for (int i = 0; i < n; i++) {
                    int prefixSum = prefixSums[i];
                    int lo = i;
                    int hi = n + 1;
                    while (hi - lo > 1) {
                        int mid = (lo + hi) / 2;
                        int subarraySum = prefixSums[mid] - prefixSum;
                        if (subarraySum < sumMid) lo = mid;
                        else hi = mid;
                    }
                    leftResult += prefixSecondSums[hi] - prefixSecondSums[i] - (lo - i) * prefixSums[i];
                }
                leftResult += sumMid * (left - ltCount);
                break;
            }
        }
        sumLo = min - 1;
        sumHi = sum + 1;
        long rightResult = 0;
        while (true) {
            int sumMid = (sumLo + sumHi) / 2;
            int ltCount = 0;
            int eqCount = 0;
            for (int i = 0; i < n; i++) {
                int prefixSum = prefixSums[i];
                int lo = i;
                int hi = n + 1;
                while (hi - lo > 1) {
                    int mid = (lo + hi) / 2;
                    int subarraySum = prefixSums[mid] - prefixSum;
                    if (subarraySum < sumMid) lo = mid;
                    else hi = mid;
                }
                ltCount += lo - i;
                if (hi <= n && prefixSums[hi] - prefixSum == sumMid) eqCount++;
            }
            if (right < ltCount) sumHi = sumMid;
            else if (ltCount + eqCount < right) sumLo = sumMid;
            else {
                for (int i = 0; i < n; i++) {
                    int prefixSum = prefixSums[i];
                    int lo = i;
                    int hi = n + 1;
                    while (hi - lo > 1) {
                        int mid = (lo + hi) / 2;
                        int subarraySum = prefixSums[mid] - prefixSum;
                        if (subarraySum < sumMid) lo = mid;
                        else hi = mid;
                    }
                    rightResult += prefixSecondSums[hi] - prefixSecondSums[i] - (lo - i) * prefixSums[i];
                }
                rightResult += sumMid * (right - ltCount);
                break;
            }
        }
        return (int)((rightResult - leftResult) % 1_000_000_007);
    }
}
