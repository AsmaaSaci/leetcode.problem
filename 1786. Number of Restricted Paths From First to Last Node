public class Solution {
    const int MOD = 1_000_000_007;
    public int CountRestrictedPaths(int n, int[][] edges) {
        var graph = new List<(int to, int wt)>[n+1];
        for(int i = 1; i<=n; i++) graph[i] = new List<(int to, int wt)>();

        foreach(var e in edges)
        {
            graph[e[0]].Add((e[1], e[2]));
            graph[e[1]].Add((e[0], e[2]));
        }

        #region Dijkstra--calculates min dist from n to all nodes.stores in dist[]
        int[] dist = new int[n+1];
        Array.Fill(dist, int.MaxValue);
        dist[n] = 0;

        var pq = new PriorityQueue<(int node, int w), int>();
        pq.Enqueue((n,0),0);

        while(pq.Count > 0)
        {
            var (u,du) = pq.Dequeue();

            if(du > dist[u]) continue;

            foreach(var (v,w) in graph[u])
            {
                if(dist[v] > du+w)
                {
                    dist[v] = du+w;
                    pq.Enqueue((v, dist[v]), dist[v]);
                }
            }
        }
        #endregion
        
        int[] memo = new int[n+1];
        Array.Fill(memo, -1);
        return DFS(1, n, graph, dist, memo);//solve recursively from start i.e. 1. return count of restricted paths

    }

    int DFS(int u, int n, List<(int, int)>[] graph, int[] dist, int[] memo)
    {
        if(u==n) return 1;
        
        if(memo[u]!= -1) return memo[u];

        int restrictedCount = 0;
        foreach(var (v, _) in graph[u])
        {
            if(dist[v] < dist[u])
            {
                restrictedCount = (restrictedCount+ DFS(v, n, graph, dist, memo))%MOD;
            }
        }
        return memo[u] = restrictedCount;
    }
}


//1 Start with Naive i.e. Dijkstra + DFS--2^n
//2 Use memo to reduce operations--(V+E)logV + E for DFS+DP, 
//3 use DP+Topo for iterative code
